list_of_algorithms = [
    "BFS",
    "DFS",
    "Dijkstra",
    "A*",
    "Greedy",
    "Bellman-Ford",
    "Floyd-Warshall",
    "Prim",
    "Kruskal",
    "Topological Sort",
    "Kahn's Algorithm",
    "Edmonds-Karp",
    "Ford-Fulkerson",
    "Dinic's Algorithm",
    "Bipartite Matching",
    "Hopcroft-Karp",
    "Kuhn's Algorithm",
    "Hungarian Algorithm",
    "Blossom Algorithm",
    "Kosaraju's Algorithm",
    "Tarjan's Algorithm",
    "Johnson's Algorithm",
    "Fleury's Algorithm",
    "Hierholzer's Algorithm",
]

list_of_sorting_algorithms = [
    "Bubble Sort", // done
    "Selection Sort", // done
    "Insertion Sort", // done
    "Quick Sort", // done
    "Merge Sort", // done
    "Radix Sort", // done
    "Heap Sort",
    "Counting Sort",
    "Bucket Sort",
    "Shell Sort",
    "Comb Sort",
    "Pigeonhole Sort",
    "Cycle Sort",
    "Cocktail Sort",
    "Gnome Sort",
    "Bitonic Sort",
    "Pancake Sort",
    "Binary Insertion Sort",
    "Bogo Sort",
    "Stooge Sort",
    "Tim Sort",
    "Tree Sort",
    "Cartesian Tree Sort",
    "Odd-Even Sort",
]

list_of_searching_algorithms = [
    "Sequential Search/Linear Search",
    "Binary Search",
    "Jump Search",
    "Interpolation Search",
    "Exponential Search",
    "Ternary Search",
    "Fibonacci Search",
    "Sublist Search",
    "Uniform Binary Search",
    "Recursive Linear Search",
    "Recursive Binary Search",
    "Recursive Jump Search",
    "Recursive Interpolation Search",
    "Recursive Exponential Search",
    "Recursive Ternary Search",
    "Recursive Fibonacci Search",
    "Recursive Sublist Search",
    "Recursive Uniform Binary Search",
]

list_of_data_structures = [
    "Array", // done
    "Linked List",
    "Stack",
    "Queue",
    "Binary Tree",
    "Binary Search Tree",
    "Heap",
    "Hashing",
    "Graph",
    "Matrix",
    "Advanced Tree",
    "Misc",
]

list_of_array_algorithms = [
    "Reverse the Array",
    "Find the maximum and minimum element in an array",
    "Find the " "Kth" " " "smallest and largest element in an array",
    "Move all the negative elements to one side of the array",
    "Find the Union and Intersection of the two sorted arrays",
    "Write a program to cyclically rotate an array by one",
    "find Largest sum contiguous Subarray [V. IMP]",
    "Minimise the maximum difference between heights [V.IMP]",
    "Minimum no. of Jumps to reach end of an array",
    "find duplicate in an array of N+1 Integers",
    "Merge 2 sorted arrays without using Extra space.",
    "Merge Intervals",
    "Next Permutation",
    "Count Inversion",
    "Best time to buy and Sell stock",
    "find all pairs on integer array whose sum is equal to given number",
    "find common elements In 3 sorted arrays",
    "Rearrange the array in alternating positive and negative items with O(1) extra space",
    "Find if there is any subarray with sum equal to 0",
    "Find factorial of a large number",
    "find maximum product subarray ",
    "Find longest coinsecutive subsequence",
    "Given an array of size n and a number k, fin all elements that appear more than " "n/k" " " "times [famous question]",
    "Maximum profit by buying and selling a share atmost twice [ IMP ]",
    "Find whether an array is a subset of another array",
    "Find the triplet that sum to a given value",
    "Trapping Rain water problem",
    "Chocolate Distribution problem",
    "Smallest Subarray with sum greater than a given value",
    "Three way partitioning of an array around a given value",
    "Minimum swaps required bring elements less equal K together",
    "Minimum no. of operations required to make an array palindrome",
    "Median of 2 sorted arrays of equal size",
    "Median of 2 sorted arrays of different size",
    "Find the point where maximum intervals overlap",
    "Maximum sum of absolute difference of an array",
    "Minimum sum of absolute difference of an array",
    "Count triplet with sum smaller than a given value",
    "merge 3 sorted arrays",
    "find index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array",
    "Maximum profit by buying and selling a share atmost k times",
    "find Largest sum contiguous Subarray [V. IMP]",
    "Minimise the maximum difference between heights [V.IMP]",
    "Minimum no. of Jumps to reach end of an array",
    "find duplicate in an array of N+1 Integers",
    "Merge 2 sorted arrays without using Extra space.",
    "Kadane's Algo [V.V.V.V.V IMP]",
    "Merge Intervals",
    "Next Permutation",
    "Count Inversion",
    "Best time to buy and Sell stock",
    "find all pairs on integer array whose sum is equal to given number",
    "find common elements In 3 sorted arrays",
    "Rearrange the array in alternating positive and negative items with O(1) extra space",
    "Find if there is any subarray with sum equal to 0",
    "Find factorial of a large number",
    "find maximum product subarray ",
    "Find longest coinsecutive subsequence",
    "Maximum profit by buying and selling a share atmost twice [ IMP ]",
    "Find whether an array is a subset of another array",
    "Find the triplet that sum to a given value",
    "Trapping Rain water problem",
    "Chocolate Distribution problem",
    "Smallest Subarray with sum greater than a given value",
    "Three way partitioning of an array around a given value",
    "Minimum swaps required bring elements less equal K together",
    "Minimum no. of operations required to make an array palindrome",
    "Median of 2 sorted arrays of equal size",
    "Median of 2 sorted arrays of different size",
    "Find the point where maximum intervals overlap",
    "Maximum sum of absolute difference of an array",
    "Minimum sum of absolute difference of an array",
    "Count triplet with sum smaller than a given value",
    "merge 3 sorted arrays",
    "find index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array",
    "Maximum profit by buying and selling a share atmost k times",
    "Find the maximum and minimum element in an array",
    "Find the " "Kth" " " "smallest and largest element in an array",
    "Move all the negative elements to one side of the array",
    "Find the Union and Intersection of the two sorted arrays",
];

list_of_linked_list_algorithms = [
    "Write a Program to reverse the Linked List. (Both Iterative and recursive)",
    "Reverse a Linked List in group of Given Size. [Very Imp]",
    "Write a program to Detect loop in a linked list.",
    "Write a program to Delete loop in a linked list.",
    "Find the starting point of the loop. ",
    "Remove Duplicates in a sorted Linked List.",
    "Remove Duplicates in a Un-sorted Linked List.",
    "Write a Program to Move the last element to Front in a Linked List.",
    "Add “1” to a number represented as a Linked List.",
    "Add two numbers represented by linked lists.",
    "Intersection of two Sorted Linked List.",
    "Intersection Point of two Linked Lists.",
    "Merge Sort For Linked lists.[Very Important]",
    "Quicksort for Linked Lists.[Very Important]",
    "Find the middle Element of a linked list.",
    "Check if a linked list is a circular linked list.",
    "Split a Circular linked list into two halves.",
    "Write a Program to check whether the Singly Linked list is a palindrome or not.",
    "Deletion from a Circular Linked List.",
    "Reverse a Doubly Linked list.",
    "Find pairs with a given sum in a DLL.",
    "Count triplets in a sorted DLL whose sum is equal to given value “X”.",
    "Sort a “k”sorted Doubly Linked list.[Very IMP]",
    "Rotate DoublyLinked list by N nodes.",
    "Rotate a Doubly Linked list in group of Given Size.[Very IMP]",
    "Can we reverse a linked list in less than O(n) ?",
    "Why Quicksort is preferred for. Arrays and Merge Sort for LinkedLists ?",
    "Flatten a Linked List",
    "Sort a LL of 0's, 1's and 2's",
    "Clone a linked list with next and random pointer",
    "Merge K sorted Linked list",
    "Multiply 2 no. represented by LL",
    "Delete nodes which have a greater value on right side",
    "Segregate even and odd nodes in a Linked List",
    "Program for n’th node from the end of a Linked List",
    "Find the first non-repeating character from a stream of characters",
    "Remove every k'th node",
    "Length of the longest substring without repeating characters",
    "Merge two sorted linked lists such that merged list is in reverse order",
    "Select a Random Node from a Singly Linked List",
];

list_of_stack_algorithms = [
    "Implement Stack from Scratch",
    "Reverse a String using Stack",
    "Evaluate Postfix expression using Stack",
    "Stock Span Problem",
    "Next Greater Element",
    "Next Smaller Element",
    "Sort a Stack using Recursion",
    "Merge Overlapping Intervals",
    "The celebrity Problem",
    "Solve the Sudoku",
    "Infix to Postfix conversion",
    "Implement two stacks in an array",
    "Find expression for a given postfix value",
    "Check for balanced parentheses",
    "Check for balanced parentheses in an expression",
    "Stock Span Problem",
    "The celebrity Problem",
    "Sort values in a stack",
    "Reverse a String using Stack",
    "Evaluate Postfix expression",
    "Implement Stack from Scratch",
    "Implement Queue from Scratch",
    "Implement 3 stacks using a single array",
    "Check for balanced parentheses in an expression",
    "Reverse a String using Stack",
    "Sort values in a stack",
    "Reverse a stack using recursion",
    "Merge Overlapping Intervals",
    "Sort a Stack using Recursion",
    "Design a Stack that supports getMin() in O(1) time and O(1) extra space.",
    "Find the next Greater element",
];

list_of_queue_algorithms = [
    "Implement Queue from Scratch",
    "Implement Stack from Scratch",
    "Implement 3 stacks using a single array",
    "Check for balanced parentheses in an expression",
    "Reverse a String using Stack",
    "Sort values in a stack",
    "Reverse a stack using recursion",
    "Merge Overlapping Intervals",
    "Sort a Stack using Recursion",
    "Design a Stack that supports getMin() in O(1) time and O(1) extra space.",
    "Find the next Greater element",
    "The celebrity Problem",
];

// bubble sort
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int temp = *a;
    *a       = *b;
    *b       = temp;
}

void bubble_sort(int arr[], int n)
{
    int i, j;

    for (i = 0; i < n - 1; i++) { // n - 1 because the last element will be sorted automatically
        for (j = 0; j < n - i - 1; j++) { // n - i - 1 because the last i elements will be sorted automatically
            if (arr[j] > arr[j + 1]) { // if the current element is greater than the next element
                swap(&arr[j], &arr[j + 1]); // swap the current element with the next element
            }
        }
    }
}

void print_array(int arr[], int n)
{
    int i;

    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

int main()
{
    int arr[] = { 64, 25, 12, 22, 11 };
    int n     = sizeof(arr) / sizeof(arr[0]);

    bubble_sort(arr, n);
    print_array(arr, n);

    return 0;
}

// selection sort
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int temp = *a;
    *a       = *b;
    *b       = temp;
}

void selection_sort(int arr[], int n)
{
    int i, j, min_idx; // min_idx is the index of the minimum element

    for (i = 0; i < n - 1; i++) { // n - 1 because the last element will be sorted automatically
        min_idx = i; // assume the first element is the minimum

        for (j = i + 1; j < n; j++) { // j = i + 1 because we don't want to compare the element with itself
            if (arr[j] < arr[min_idx]) { // if the current element is less than the minimum element
                min_idx = j; // update the index of the minimum element
            }
        }

        swap(&arr[min_idx], &arr[i]); // swap the minimum element with the first element
    }
}

void print_array(int arr[], int n)
{
    int i;

    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

int main()
{
    int arr[] = { 64, 25, 12, 22, 11 };
    int n     = sizeof(arr) / sizeof(arr[0]);

    selection_sort(arr, n);
    print_array(arr, n);

    return 0;
}

// insertion sort
#include <stdio.h>
#include <stdlib.h>

void insertion_sort(int arr[], int n)
{
    int i, j, key;

    for (i = 1; i < n; i++) { // i = 1 because the first element is already sorted
        key = arr[i]; // key is the element to be inserted

        j = i - 1; // j is the index of the element before the key

        while (j >= 0 && arr[j] > key) { // while j is not out of bounds and the element before the key is greater than the key
            arr[j + 1] = arr[j]; // move the element before the key to the right
            j--; // decrement j
        }

        arr[j + 1] = key; // insert the key
    }
}

void print_array(int arr[], int n)
{
    int i;

    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

int main()
{
    int arr[] = { 64, 25, 12, 22, 11 };
    int n     = sizeof(arr) / sizeof(arr[0]);

    insertion_sort(arr, n);
    print_array(arr, n);

    return 0;
}

// quick sort
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int temp = *a;
    *a       = *b;
    *b       = temp;
}

int partition(int arr[], int low, int high)
{
    int pivot = arr[high]; // pivot is the last element
    int i     = low - 1; // i is the index of the smaller element

    for (int j = low; j < high; j++) { // j = low because we don't want to compare the pivot with itself
        if (arr[j] < pivot) { // if the current element is less than the pivot
            i++; // increment i
            swap(&arr[i], &arr[j]); // swap the current element with the element at index i
        }
    }

    swap(&arr[i + 1], &arr[high]); // swap the pivot with the element at index i + 1

    return i + 1; // return the index of the pivot
}

void quick_sort(int arr[], int low, int high)
{
    if (low < high) { // if low is less than high
        int pi = partition(arr, low, high); // pi is the index of the pivot

        quick_sort(arr, low, pi - 1); // sort the elements before the pivot
        quick_sort(arr, pi + 1, high); // sort the elements after the pivot
    }
}

void print_array(int arr[], int n)
{
    int i;

    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

int main()
{
    int arr[] = { 64, 25, 12, 22, 11 };
    int n     = sizeof(arr) / sizeof(arr[0]);

    quick_sort(arr, 0, n - 1);
    print_array(arr, n);

    return 0;
}

// merge sort
#include <stdio.h>
#include <stdlib.h>

void merge(int arr[], int l, int m, int r)
{
    int i, j, k; // i is the index of the left subarray, j is the index of the right subarray, k is the index of the merged subarray
    int n1 = m - l + 1; // n1 is the size of the left subarray
    int n2 = r - m; // n2 is the size of the right subarray
    int L[n1], R[n2]; // L is the left subarray, R is the right subarray

    for (i = 0; i < n1; i++) { // copy the elements of the left subarray
        L[i] = arr[l + i];
    }

    for (j = 0; j < n2; j++) { // copy the elements of the right subarray
        R[j] = arr[m + 1 + j];
    }

    i = 0; // reset i
    j = 0; // reset j
    k = l; // reset k

    while (i < n1 && j < n2) { // while i and j are not out of bounds
        if (L[i] <= R[j]) { // if the current element of the left subarray is less than or equal to the current element of the right subarray
            arr[k] = L[i]; // copy the current element of the left subarray to the merged subarray
            i++; // increment i
        } else { // if the current element of the left subarray is greater than the current element of the right subarray
            arr[k] = R[j]; // copy the current element of the right subarray to the merged subarray
            j++; // increment j
        }

        k++; // increment k
    }

    while (i < n1) { // while i is not out of bounds
        arr[k] = L[i]; // copy the current element of the left subarray to the merged subarray
        i++; // increment i
        k++; // increment k
    }

    while (j < n2) { // while j is not out of bounds
        arr[k] = R[j]; // copy the current element of the right subarray to the merged subarray
        j++; // increment j
        k++; // increment k
    }
}

void merge_sort(int arr[], int l, int r)
{
    if (l < r) { // if l is less than r
        int m = l + (r - l) / 2; // m is the middle index

        merge_sort(arr, l, m); // sort the left subarray
        merge_sort(arr, m + 1, r); // sort the right subarray

        merge(arr, l, m, r); // merge the left and right subarrays
    }
}

void print_array(int arr[], int n)
{
    int i;

    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

int main()
{
    int arr[] = { 64, 25, 12, 22, 11 };
    int n     = sizeof(arr) / sizeof(arr[0]);

    merge_sort(arr, 0, n - 1);
    print_array(arr, n);

    return 0;
}

// radix sort
#include <stdio.h>
#include <stdlib.h>

int get_max(int arr[], int n)
{
    int i;
    int max = arr[0];

    for (i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    return max;
}

void count_sort(int arr[], int n, int exp)
{
    int i; // i is the index of the array
    int output[n]; // output is the array of the sorted elements
    int count[10] = { 0 }; // count is the array of the count of the digits

    for (i = 0; i < n; i++) { // store the count of the digits
        count[(arr[i] / exp) % 10]++; // increment the count of the digit
    }

    for (i = 1; i < 10; i++) { // store the position of the digits
        count[i] += count[i - 1]; // add the count of the previous digit to the count of the current digit
    }

    for (i = n - 1; i >= 0; i--) { // store the sorted elements
        output[count[(arr[i] / exp) % 10] - 1] = arr[i]; // store the element at the position of the digit
        count[(arr[i] / exp) % 10]--; // decrement the count of the digit
    }

    for (i = 0; i < n; i++) { // copy the sorted elements to the original array
        arr[i] = output[i]; // copy the element
    }
}

void radix_sort(int arr[], int n)
{
    int i;
    int m = get_max(arr, n);

    for (i = 1; m / i > 0; i *= 10) { // i is the exponent of the digit to be sorted by count sort (1, 10, 100, ...)
        count_sort(arr, n, i);
    }
}

void print_array(int arr[], int n)
{
    int i;

    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

int main()
{
    int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };
    int n     = sizeof(arr) / sizeof(arr[0]);

    radix_sort(arr, n);
    print_array(arr, n);

    return 0;
}
